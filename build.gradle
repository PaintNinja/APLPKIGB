plugins {
    id 'groovy'
    id 'java-library'
    id 'maven-publish'
    id 'com.github.ben-manes.versions' version '0.42.0'
    id 'com.github.johnrengelman.shadow' version '7.1.2' apply false
    id 'net.minecraftforge.gradle' version '5.1.+'
    id 'org.cadixdev.licenser' version '0.6.1'
}

import com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar
import com.github.jengelman.gradle.plugins.shadow.transformers.Transformer
import com.github.jengelman.gradle.plugins.shadow.transformers.TransformerContext
import shadow.org.apache.tools.zip.ZipEntry
import shadow.org.apache.tools.zip.ZipOutputStream
import shadow.org.codehaus.plexus.util.IOUtil
import groovy.lang.Closure

class UpdatedGroovyExtensionModuleTransformer implements Transformer {

    private static final GROOVY_EXTENSION_MODULE_DESCRIPTOR_PATH =
            "META-INF/groovy/org.codehaus.groovy.runtime.ExtensionModule" // The only change...

    private static final MODULE_NAME_KEY = 'moduleName'
    private static final MODULE_VERSION_KEY = 'moduleVersion'
    private static final EXTENSION_CLASSES_KEY = 'extensionClasses'
    private static final STATIC_EXTENSION_CLASSES_KEY = 'staticExtensionClasses'

    private static final MERGED_MODULE_NAME = 'MergedByShadowJar'
    private static final MERGED_MODULE_VERSION = '1.0.0'

    private final Properties module = new Properties()

    @Override
    boolean canTransformResource(FileTreeElement element) {
        return element.relativePath.pathString == GROOVY_EXTENSION_MODULE_DESCRIPTOR_PATH
    }

    @Override
    void transform(TransformerContext context) {
        def props = new Properties()
        props.load(context.is)
        props.each { String key, String value ->
            switch (key) {
                case MODULE_NAME_KEY:
                    handle(key, value) {
                        module.setProperty(key, MERGED_MODULE_NAME)
                    }
                    break
                case MODULE_VERSION_KEY:
                    handle(key, value) {
                        module.setProperty(key, MERGED_MODULE_VERSION)
                    }
                    break
                case [EXTENSION_CLASSES_KEY, STATIC_EXTENSION_CLASSES_KEY]:
                    handle(key, value) { String existingValue ->
                        def newValue = "${existingValue},${value}"
                        module.setProperty(key, newValue)
                    }
                    break
            }
        }
    }

    private handle(String key, String value, Closure mergeValue) {
        def existingValue = module.getProperty(key)
        if (existingValue) {
            mergeValue(existingValue)
        } else {
            module.setProperty(key, value)
        }
    }

    @Override
    boolean hasTransformedResource() {
        return module.size() > 0
    }

    @Override
    void modifyOutputStream(ZipOutputStream os, boolean preserveFileTimestamps) {
        ZipEntry entry = new ZipEntry(GROOVY_EXTENSION_MODULE_DESCRIPTOR_PATH)
        entry.time = TransformerContext.getEntryTimestamp(preserveFileTimestamps, entry.time)
        os.putNextEntry(entry)
        IOUtil.copy(toInputStream(module), os)
        os.closeEntry()
    }

    private static InputStream toInputStream(Properties props) {
        def baos = new ByteArrayOutputStream()
        props.store(baos, null)
        return new ByteArrayInputStream(baos.toByteArray())
    }
}

static String getGitCommit() {
    def proc = 'git rev-parse --short HEAD'.execute()
    proc.waitFor()
    return proc.exitValue()? "ERROR(${proc.exitValue()})" : proc.text.trim()
}

def groovy(def name) {
    return [
            group: 'org.apache.groovy',
            name: name == 'stdlib'? 'groovy' : "groovy-${name}",
            version: project.ext.groovyVersion
    ]
}

version = '1.1.0'
group = 'net.thesilkminer.mc.austin'
archivesBaseName = 'austin-powerful-language-provider-keeping-it-groovy-baby'

java {
    toolchain.languageVersion = JavaLanguageVersion.of(JavaVersion.VERSION_17.majorVersion)
    withSourcesJar()
}

license {
    header(project.file('NOTICE'))

    ext['year'] = Calendar.getInstance().get(Calendar.YEAR)
    ext['name'] = 'TheSilkMiner'
    ext['app'] = 'APLP: KIGB'
}

minecraft {
    mappings channel: 'official', version: '1.19'

    runs {
        client {
            workingDirectory project.file('run_client')

            property 'forge.logging.console.level', 'debug'

            lazyToken('minecraft_classpath') {
                return tasks.allJar.archiveFile.get().asFile.absolutePath
            }

            mods {
                mojotest {
                    source sourceSets.test
                }
            }
        }

        server {
            workingDirectory project.file('run_server')

            property 'forge.logging.console.level', 'debug'

            args 'nogui'

            lazyToken('minecraft_classpath') {
                return tasks.allJar.archiveFile.get().asFile.absolutePath
            }

            mods {
                mojotest {
                    source sourceSets.test
                }
            }
        }
    }
}

sourceSets {
    ast {} // Everything related to AST transformations
    dsl {} // Additional DSLs, courtesy of Paint
    dslmod {} // Mod entry for DSL
    // main = ITransformationService, written in Java
    provider {} // Language Provider + API
    rt {} // Runtime Components for the mod
    rtmod {} // Mod entry for Runtime Components
}

configurations {
    shade {}
    yeet {}
    api.extendsFrom(shade)

    providerImplementation.extendsFrom minecraft, shade
    rtImplementation.extendsFrom providerImplementation
    dslImplementation.extendsFrom rtImplementation, providerImplementation
    astImplementation.extendsFrom rtImplementation, dslImplementation, providerImplementation
    dslmodImplementation.extendsFrom dslImplementation, astImplementation
    rtmodImplementation.extendsFrom rtImplementation, astImplementation

    testImplementation.extendsFrom astImplementation, dslImplementation, rtImplementation, providerImplementation

    runtimeElements.extendsFrom = []
}

repositories {
    mavenCentral()
}

dependencies {
    minecraft group: 'net.minecraftforge', name: 'forge', version: "${mcVersion}-41.0.110"
    shade groovy('stdlib')
    shade groovy('ant')
    shade groovy('astbuilder')
    yeet groovy('backports-compat-23')
    yeet groovy('binary')
    yeet groovy('bom')
    yeet groovy('bsf')
    shade groovy('cli-picocli')
    yeet groovy('cli-commons')
    shade groovy('contracts')
    yeet groovy('console')
    shade groovy('datetime')
    shade groovy('dateutil')
    yeet groovy('docgenerator')
    shade groovy('ginq')
    yeet groovy('groovydoc')
    yeet groovy('groovysh')
    yeet groovy('jaxb')
    yeet groovy('jmx')
    shade groovy('json')
    shade groovy('jsr223')
    shade groovy('macro')
    shade groovy('macro-library')
    shade groovy('nio')
    yeet groovy('servlet')
    yeet groovy('sql')
    yeet groovy('swing')
    shade groovy('templates')
    shade groovy('test')
    shade groovy('test-junit5')
    yeet groovy('testng')
    shade groovy('toml')
    shade groovy('typecheckers')
    shade groovy('xml')
    shade groovy('yaml')

    rtImplementation sourceSets.provider.output
    dslImplementation sourceSets.provider.output
    dslImplementation sourceSets.rt.output
    astImplementation sourceSets.provider.output
    astImplementation sourceSets.rt.output
    astImplementation sourceSets.dsl.output

    dslmodImplementation sourceSets.ast.output
    rtmodImplementation sourceSets.ast.output

    testImplementation sourceSets.ast.output
    testImplementation sourceSets.dsl.output
    testImplementation sourceSets.rt.output
    testImplementation sourceSets.provider.output
}

def jarManifest = manifest {
    attributes([
            'Specification-Title': 'austins-powerful-language-provider-keeping-it-groovy-baby',
            'Specification-Vendor': 'TheSilkMiner',
            'Specification-Version': 1,
            'Implementation-Title': project.name,
            'Implementation-Version': project.version,
            'Implementation-Vendor' : 'TheSilkMiner',
            'Implementation-Timestamp': new Date().format(/yyyy-MM-dd'T'HH:mm:ssZ/),
            'GitCommit': getGitCommit()
    ])
}

task groovyJar(type: ShadowJar) {
    archiveClassifier = 'groovy'
    configurations = [project.configurations.shade]
    [
            '**/module-info.class',
            'LICENSE.txt',
            'LICENSE-junit.txt',
            'META-INF/LICENSE.txt',
            'META-INF/LICENSE.md',
            'META-INF/NOTICE.txt',
            '**/*.kotlin-module'
    ].each { exclude it }
    manifest {
        from jarManifest
        attributes([
                'GroovyMarker': true
        ])
    }
    transform(UpdatedGroovyExtensionModuleTransformer)
    mergeServiceFiles()
}

task providerJar(type: Jar) {
    archiveClassifier = 'provider'
    from project.sourceSets.provider.output
    [
            'LICENSE.txt',
            '**/*.psd'
    ].each { exclude it }
    manifest {
        from jarManifest
        attributes([
                'FMLModType': 'LANGPROVIDER',
                'Automatic-Module-Name': 'net.thesilkminer.mc.aplpkigb.provider'
        ])
    }
}

task rtJar(type: Jar) {
    archiveClassifier = 'rt'
    from project.sourceSets.rt.output
    from project.sourceSets.rtmod.output
    exclude '**/*.psd'

    manifest {
        from jarManifest
        attributes([
                'Automatic-Module-Name': 'net.thesilkminer.mc.aplpkigb.rt'
        ])
    }
}

task dslJar(type: Jar) {
    archiveClassifier = 'dsl'
    from project.sourceSets.dsl.output
    from project.sourceSets.dslmod.output
    exclude '**/*.psd'

    manifest {
        from jarManifest
        attributes([
                'Automatic-Module-Name': 'net.thesilkminer.mc.aplpkigb.dsl' // TODO('Replace with Paint')
        ])
    }
}

task astJar(type: Jar) {
    archiveClassifier = 'ast'
    from project.sourceSets.ast.output
    exclude '**/*.psd'

    manifest {
        from jarManifest
        attributes([
                'Automatic-Module-Name': 'net.thesilkminer.mc.aplpkigb.ast'
        ])
    }
}

jar {
    archiveClassifier = ''
    manifest {
        from jarManifest
        attributes([
            'Automatic-Module-Name': 'net.thesilkminer.mc.aplpkigb.boot'
        ])
    }
}

task allJar(type: Jar) {
    archiveClassifier = 'all'
    from groovyJar
    from providerJar
    from rtJar
    //from dslJar
    from astJar
    from sourceSets.main.output
    manifest {
        from jarManifest
        attributes([
                'Automatic-Module-Name': 'net.thesilkminer.mc.aplpkigb.boot'
        ])
    }
}

task testJar(type: Jar) {
    from sourceSets.test.output
    archiveClassifier = 'test'
}

[ tasks.groovyJar, tasks.dslJar, tasks.astJar, tasks.rtJar, tasks.jar, tasks.allJar, tasks.providerJar ].each {
    it.archiveBaseName = 'aplp'
}

configurations.apiElements {
    [
            tasks.providerJar,
            //tasks.dslJar,
            tasks.astJar,
            tasks.rtJar
    ].each { outgoing.artifact(it) }
}
configurations.runtimeElements {
    outgoing.artifacts.clear()
    outgoing.artifact(tasks.allJar)
}

publishing {
    publications {
        mavenJava(MavenPublication) {
            from components.java
            artifactId = "aplp-${mcVersion}"
            pom.withXml { node ->
                node.asNode().dependencies
                        .'*'
                        .findAll { it.version.text().contains('mapped') }
                        .each { it.parent().remove(it) }
            }
        }
    }
    repositories {
        maven {
            name = 'ModdingInquisitionMavenRepo'
            url = 'https://maven.moddinginquisition.org/snapshots'
            credentials {
                username = 'username'
                password = 'password'
            }
        }
//        maven {
//            url = uri("file://${System.getenv("local_maven")}")
//        }
    }
}

reobf {
    allJar {}
    dslJar {}
    rtJar {}
    testJar {}
}

tasks.withType(GroovyCompile).configureEach {
    groovyOptions.optimizationOptions.indy = true
}

tasks.whenTaskAdded {
    if (it.name == 'prepareRuns') {
        it.dependsOn(allJar)
    }
}

allJar.finalizedBy('reobfAllJar')
dslJar.finalizedBy('reobfDslJar')
jar.finalizedBy('reobfJar')
rtJar.finalizedBy('reobfRtJar')
testJar.finalizedBy('reobfTestJar')

testJar.dependsOn('reobfAllJar')
build.dependsOn('testJar')

wrapper {
    gradleVersion = '7.4.2'
    distributionType = Wrapper.DistributionType.ALL
}
